estUstarThreshold <- function(
		### estimate the Ustar threshold by aggregating the estimates for seasonal and temperature subsets 
		ds						    ##<< data.frame with columns
		,UstarColName = "Ustar"		##<< collumn name for UStar
		,NEEColName = "NEE"			##<< collumn name for NEE
		,TempColName = "Tair"		##<< collumn name for air temperature
		,RgColName = "Rg"			##<< collumn name for solar radiation for omitting night time data
		,seasonFactor.v = createSeasonFactorMonth(ds$DateTime) ##<< factor for subsetting times see details 
		,ctrlUstarEst.l = controlUstarEst()			##<< control parameters for estimating uStar on a single binned series, see \code{\link{controlUstarEst}}
		,ctrlUstarSub.l = controlUstarSubsetting()	##<< control parameters for subsetting time series (number of temperature and Ustar classes \ldots), see \code{\link{controlUstarSubsetting}} 
		,fEstimateUStarBinned = estUstarThresholdSingleFw2Binned	##<< function to estimate UStar on a single binned series, see \code{\link{estUstarThresholdSingleFw2Binned}}
		,isCleaned=FALSE			##<< set to TRUE to avoid call to \code{\link{cleanUStarSeries}}.
){
	##references<< Ustar filtering following the idea in Papale 2006	
	# subset for first season
	# TODO: implement seasonal functionality
	#dsi <- subset(ds, seasonFactor.v == 1)
	##details<<
	## UStar threshold is estimated for different subsets of the time series.
	## From the estimates for each season (each value in \code{seasonFactor.v}) the maximum is reported as global estimate.
	## Within each season the time series is split by temperature classes. Among these Ustar estimates, the median is reported as season value.
	##
	## In order to split the seasons, the uses has provide a vector with argument \code{seasonFactor.v}
	## where rows with the same value belong to
	## the same season. It is conveniently generated by one of the following functions:
	## \itemize{
	## 	\item{ \code{\link{createSeasonFactorMonth}} (default) }
	## 	\item{ \code{\link{createSeasonFactorYday}} }
	## } 
	##
	## The estimation of Ustar on a single binned series can be selected argument \code{fEstimateUStarBinned}.
	## \itemize{
	## 	\item{ \code{\link{estUstarThresholdSingleFw1Binned}} }
	## 	\item{ \code{\link{estUstarThresholdSingleFw2Binned}} (default) }
	## } 
	##
	## This function is usually called by
	## \itemize{
	## \item{ \code{\link{estUstarThresholdYears}} that applies it to subsets of each year. }
	## \item{ \code{\link{estUstarThresholdDistribution}} which additionally bootstraps the median and confidence intervals for each year.}
	## } 
	
	dsF <- cbind(ds,season=seasonFactor.v)
	dsc <- if( isCleaned) dsF else cleanUStarSeries( dsF, UstarColName, NEEColName, TempColName, RgColName, ctrlUstarSub.l$swThr)
	dsi <- subset(dsc, season == 5)
	UstarSeasons <- daply(dsc, .(season), function(dsi){
				#cat(dsi$season[1], as.POSIXlt(dsi$DateTime[1])$mon, ",")
				dsiSort <- arrange(dsi, dsi[,TempColName]) 	#sort values in a season by air temperature and then by UStar
				N <- nrow(dsi ) #number of observations (rows) total, probably can get from elsewhere..
				T_bin_size <- round(N/ctrlUstarSub.l$taClasses) #set T_bin size so that every bin has equal #values
				if( T_bin_size < ctrlUstarSub.l$UstarClasses*2 ){
					warning("estUstarThresholdYear: season ",dsi$season[1], " has too few cases: n=", N)
					return( rep(NA_real_, ctrlUstarSub.l$taClasses))
				} 
				#set up vector that contains Ustar values for temperature classes
				UstarTh.v = vector(length=ctrlUstarSub.l$taClasses)
				#k<-1
				for (k in 1:ctrlUstarSub.l$taClasses){
					#print(k)
					#if( k == 4 ) recover()
					#original Dario's C version...
					#ta_class_start = 0;
					#ta_class_end = season_start_index;
					#/* set start & end indexes */
					#  ta_class_start = ta_class_end;
					#ta_class_end = season_start_index + (ta_samples_count*(i+1)-1);
					
					#/om:this part only implemented for checking C code compatibility...
					#ta_class_start = ta_class_end
					#ta_class_end = ta_class_start + T_bin_size-1
					#/eom
					
					#subset into Ta classes
					if (k==ctrlUstarSub.l$taClasses){ # use end index of vector for slightly smaller last bin (due to rounding) 
						dsiSortTclass <- dsiSort[((k-1)*T_bin_size+1):N,]
					} else {
						dsiSortTclass <- dsiSort[((k-1)*T_bin_size+1):((k)*T_bin_size),]
					}
					#constraint: u* threshold only accepted if T and u* are not or only weakly correlated..
					Cor1 = suppressWarnings( abs(cor(dsiSortTclass[,UstarColName],dsiSortTclass[,TempColName])) ) # maybe too few or degenerate cases
					# TODO: check more correlations here? [check C code]
					#      Cor2 = abs(cor(dataMthTsort$Ustar,dataMthTsort$nee))
					#      Cor3 = abs(cor(dataMthTsort$tair,dataMthTsort$nee))
					if( (is.finite(Cor1)) && (Cor1 < ctrlUstarEst.l$corrCheck)){ #& Cor2 < CORR_CHECK & Cor3 < CORR_CHECK){
						dsiBinnedUstar <- binUstar(dsiSortTclass[,NEEColName],dsiSortTclass[,UstarColName],ctrlUstarSub.l$UstarClasses)
						if( any(!is.finite(dsiBinnedUstar[,2])) ){
							recover()
							stop("Encountered non-finite average NEE for a UStar bin.",
									"You need to provide data with non-finite collumns uStar and NEE for UStar Threshold detection.")
						}
						UstarTh.v[k]=fEstimateUStarBinned(  dsiBinnedUstar, ctrlUstarEst.l = ctrlUstarEst.l)
					} else { #correlation between T and u* too high
						#fill respective cell with NA
						UstarTh.v[k] = NA
						#TODO: should a message be printed here to the user??
					}
				}
				UstarTh.v # vector of uStar for temperature classes
			},.drop_o = FALSE) # daply over seasons  matrix (nTemp x nSeason)
	uStarAggr <- max( apply( UstarSeasons, 1, median, na.rm=TRUE), na.rm=TRUE)
	##value<< A list with entries
	list(
			UstarAggr=uStarAggr				##<< numeric scalar: Ustar threshold estimate:  max_Seasons( median_TempClasses )
			,UstarSeasonTemp=UstarSeasons	##<< numeric matrix (nSeason x nTemp): estimates for each subset
	)
}
attr(estUstarThreshold,"ex") <- function(){
	Dir.s <- paste(system.file(package='REddyProc'), 'examples', sep='/')
	EddyData.F <- ds <- fLoadTXTIntoDataframe('Example_DETha98.txt', Dir.s)
	EddyDataWithPosix.F <- ds <- fConvertTimeToPosix(EddyData.F, 'YDH', Year.s='Year', Day.s='DoY', Hour.s='Hour')
	(res <- estUstarThreshold(ds))
}


controlUstarEst <- function(
  ### Default list of parameters for determining UStar of a single binned series	
  #T Classes not needed here?
  # either?
  #,taClasses=7 # set number of ta classes   
  # or?
  #,ctrlUstarSubsetting.l = controlUstarSubsetting()
  #,taClasses=ctrlUstarSubsetting.l$taClasses  
  #
  #,percentile = 90 #percentile value... double check!
  #,percentile_check = TRUE #enable percentile check\n ... double check!
  ustPlateauFwd = 10 	##<< number of subsequent thresholds to compare to in fwd mode
  ,ustPlateauBack = 6	##<< number of subsequent thresholds to compare to in back mode  
  ,plateauCrit = 0.95	##<< significant differences between a u* value and the mean of a "plateau"
  ,corrCheck = 0.5 		##<< threshold value for correlation between Tair and u* data
  ,bt = FALSE 			##<< flag for bootstrapping
  ,btTimes = 100 		##<< number of bootstrap samples
  
  #,method.v = function... #fw2 by default..
  
  #TODO: what does the following param do?
  #define FIRST_Ustar_MEAN_CHECK  		0.2  
  # 4.) const int percentiles[PERCENTILES_COUNT] = { 5, 10, 25, 50, 75, 90, 95};
  
){
  ##seealso<< \code{\link{estUstarThresholdSingleFw2Binned}}, \code{\link{controlUstarSubsetting}} 
  ctrl <- list(  
    #taClasses=taClasses
    #,UstarClasses=UstarClasses  
    #percentile = percentile
    #percentile_check = percentile_check #enable percentile check\n ... double check!
    ustPlateauFwd = ustPlateauFwd #number of subsequent thresholds to compare to in fwd mode
    ,ustPlateauBack = ustPlateauBack #number of subsequent thresholds to compare to in back mode  
    ,plateauCrit = plateauCrit #significant differences between a u* value and the mean of a "plateau"
    ,corrCheck = corrCheck #threshold value for correlation between Tair and u* data
    #,seasons = seasons # switch for three different seasonal modes 
    #(seasons or "groupby" may easily extended to an input vector or matrix)
    ,bt = bt #flag for bootstrapping
    ,btTimes = btTimes #number of bootstrap samples
  )
  #display warning message for the following variables that we advise not to be changed
  if (corrCheck != 0.5) warning("WARNING: parameter corrCheck set to non default value!")
  ctrl
}
attr(controlUstarEst,"ex") <- function(){
	controlUstarEst()
}

controlUstarSubsetting <- function(
	### Default list of parameters for determining UStar of a single binned series	
	taClasses=7 		##<< set number of air temperature classes 
	,UstarClasses=20 	##<< set number of Ustar classes 	
	# seasons param deprecated
  # TODO: add seasons handling to documentation
  #,seasons = 1 # switch for different seasonal modes #TODO: Update?!
	,swThr = 10  # nighttime data threshold [Wm-2]  
	
	# 1.) ,selection parameter for which fwd and back modes? fwd2 as default... 
	# 2.) ,MIN_VALUE_PERIOD <<- 3000 # per whole data set... double check C code
	# 3.) ,MIN_VALUE_SEASON <<- 160 #if #number of data points in one any season are smaller than that, merge to one big season
	#define MIN_VALUE_PERIOD    		3000		/* min values for compute u* threshold */
	#define MIN_VALUE_SEASON				160			/* min for seasons */
	#define TA_CLASS_MIN_SAMPLE				100
  ){  
	##seealso<< \code{\link{estUstarThresholdSingleFw2Binned}}, \code{\link{controlUstarSubsetting}} 
	ctrl <- list(
    	taClasses=taClasses
		,UstarClasses= UstarClasses
  		#,seasons
  		,swThr = swThr
  )	
  if (ctrl$swThr != 10) warning("WARNING: parameter swThr set to non default value!")
  if (ctrl$taClasses != 7) warning("WARNING: parameter taClasses set to non default value!")	
  if (ctrl$UstarClasses != 20) warning("WARNING: parameter UstarClasses set to non default value!")
  ctrl
}
attr(controlUstarSubsetting,"ex") <- function(){
	controlUstarSubsetting()
}

createSeasonFactorMonth <- function(
	### calculate factors to denote the season for uStar-Filtering by specifying starting months
  	dates							##<< POSIXct vector of length of the data set to be filled				
  	, month=as.POSIXlt(dates)$mon   ##<< integer (0-11) vector of length of the data set to be filled, specifying the month for each record  
	, startMonth=c(12,3,6,9)-1		##<< integer vector specifying the starting month for each season, counting from zero
){
  ##seealso<< \code{\link{createSeasonFactorYday}}
  startMonth <- sort(unique(startMonth))
  boLastPeriod <- month < startMonth[1] 		# translate month before the first specified beginning month to be after last specified month
  month[ boLastPeriod ] <- month[ boLastPeriod] +12
  startMonthAdd <- c(startMonth, startMonth[1]+12)
  seasonFac <- rep(as.integer(1), length(month) )
  # i <- 2
  for( i in 2:length(startMonth) ){
	  seasonFac[ month >= startMonthAdd[i] & month < startMonthAdd[i+1] ] <- i
  }
  #plot( seasonFac ~ months )
  seasonFac 	
  ##value<<
  ## Integer vector of nrow ds, with each unique value representing one season
}
attr(createSeasonFactorMonth,"ex") <- function(){
	Dir.s <- paste(system.file(package='REddyProc'), 'examples', sep='/')
	EddyData.F <- dss <- fLoadTXTIntoDataframe('Example_DETha98.txt', Dir.s)
	EddyDataWithPosix.F <- ds <- fConvertTimeToPosix(dss, 'YDH', Year.s='Year', Day.s='DoY', Hour.s='Hour')
	(res <- createSeasonFactorMonth(ds$DateTime))
	(res2 <- createSeasonFactorYday(ds$DateTime)) # default days are chosen to correspond to start of Febr, June, Sept, and Dec
}


createSeasonFactorYday <- function(
	### calculate factors to denote the season for uStar-Filtering by specifying starting day of years
	dates							##<< POSIXct vector of length of the data set to be filled				
	, yday=as.POSIXlt(dates)$yday  ##<< integer (0-11) vector of length of the data set to be filled, specifying the month for each record  
	, startYday=c(335,60,152,244)-1	##<< integer vector (0-366) specifying the starting month for each season
){
	startYday <- sort(unique(startYday))
	boLastPeriod <- (yday < startYday[1])	# days before the first starting day will be in last period 
	yday[ boLastPeriod ] <- yday[ boLastPeriod] +366  # translate day to be after last specified startday 
	startYdayAdd <- c(startYday, startYday[1]+366)  # 
	seasonFac <- rep(as.integer(1), length(yday) )
	# i <- 2
	for( i in 2:length(startYday) ){
		seasonFac[ yday >= startYdayAdd[i] & yday < startYdayAdd[i+1] ] <- i
	}
	#plot( monthsFac ~ months )
	seasonFac 	
	##value<<
	## Integer vector of nrow ds, each unique class representing one season
}


binUstar <- function(
	### Bin the NEE for a number of classes of UStar classes
	NEE.v				##<< vector with value of Net Ecosystem exchange
	,Ustar.v 			##<< vector with u* (friction velocity (m2/s)
	,UstarClasses=controlUstarSubsetting()$UstarClasses	##<< the number of binning classes
	,isUStarSorted=FALSE	##<< set to TRUE, if NEE and Ustar are already sorted by increasin Ustar values (performance gain)

){
	ds.f <- data.frame(NEE=NEE.v,Ustar=Ustar.v)
	
	#within data frame sort values by Ustar
	if( !isTRUE(isUStarSorted))	ds.f <- arrange(ds.f,ds.f[,2])
	
	N_T <- length(NEE.v) #number of observations(rows) 
	Ust_bin_size <- round(N_T/UstarClasses)
	
	#set up data frame for bin averages (by Ustar)
	Ust_bins.m <- matrix(NA,UstarClasses,2)
	Ust_bins.f <- data.frame(Ust_bins.m)
	names(Ust_bins.f)[1]="Ust_avg"; names(Ust_bins.f)[2]="NEE_avg";
	#names(Ust_bins.f)[3]="N";
	
	#calculate u* bin averages
	for (u in 1:UstarClasses){
		#/om:this part only implemented for checking C code compatibility...
		#ust_class_start = ust_class_end
		#ust_class_end = ust_class_start + Ust_bin_size-1
		#dataUstclass <- dataTclass[ust_class_start:ust_class_end,]
		#/eom    
		if (u==UstarClasses){ 
			# use end index of vector for slightly smaller last bin (due to rounding) 
			dsUstClass.f <- ds.f[((u-1)*Ust_bin_size+1):N_T,]
		}
		else {
			dsUstClass.f <- ds.f[((u-1)*Ust_bin_size+1):((u)*Ust_bin_size),]
		}
		#TODO: merge two following lines to one
		Ust_bins.f$NEE_avg[u] <- mean(dsUstClass.f[,1], na.rm=T) #mean of NEE over Ustar bins
		Ust_bins.f$Ust_avg[u] <- mean(dsUstClass.f[,2], na.rm=T) #mean of Ustar bins
		#Ust_bins.f$N[u] <- sum(!is.na(dataUstclass$nee))
	}
	#Ust_bins.f[,2][ !is.finite(Ust_bins.f[,2]) ] <- NA	# only allow finite values (no NaN)
	Ust_bins.f
}
attr(binUstar,"ex") <- function(){
	Dir.s <- paste(system.file(package='REddyProc'), 'examples', sep='/')
	EddyData.F <- ds <- fLoadTXTIntoDataframe('Example_DETha98.txt', Dir.s)
	EddyDataWithPosix.F <- ds <- fConvertTimeToPosix(EddyData.F, 'YDH', Year.s='Year', Day.s='DoY', Hour.s='Hour')
	dss <- subset(EddyDataWithPosix.F, DoY >= 150 & DoY <= 250)
	(res <- binUstar(dss$NEE, dss$Ustar))
	(resFW1 <- estUstarThresholdSingleFw1Binned(res))
	(resFW2 <- estUstarThresholdSingleFw2Binned(res))
}


estUstarThresholdSingleFw1Binned <- function(
		### estimate the Ustar threshold for single subset, using FW1 algorithm, relying on binned NEE and Ustar
		Ust_bins.f			##<< data.frame with columns NEE_avg and Ust_avg, of NEE by Ustar bins by \code{\link{binUstar}}
		,ctrlUstarEst.l = controlUstarEst() ##<< parameter list, see \code{\link{controlUstarEst}} for defaults and description
){
	##references<< inspired by Papale 2006
	
	# algorithm to check when plateau is reached
	flag <- FALSE
	#for every u* bin compare to avg of subsequent UST_PLATEAU, until found
	u <- 1
	#TODO: change to for loop 1:ustClasses and then break
	# in order to avoid infinite loop in case of error
	# optimize with Thomas?
	
  while (!flag){ #only stop if threshold is found
		if (!flag & (Ust_bins.f$NEE_avg[u] >= (ctrlUstarEst.l$plateauCrit*mean(Ust_bins.f$NEE_avg[(u+1):(u+ctrlUstarEst.l$ustPlateauFwd)],na.rm=T)))){ #na.rm=T to exclude NAs out of bounds..
			#   NEE_i >= .95*avg(i,i+1,...,i+10)  [FW]    
			UstarThSingle <- Ust_bins.f$Ust_avg[u]        
			flag <- TRUE #set flag for threshold found in this mode
		}          
		#case that no threshold could be found by plateau method, use maximum u* in that T_class...
		if (u==(nrow(Ust_bins.f)-1)){ #FW1: -1 ; FW2: 
			UstarThSingle <- Ust_bins.f$Ust_avg[u+1]        
			break;      
		}
		u <- u+1 #increase index by 1
	}  
	return(UstarThSingle)
}

# TODO: restructure? may not be the most efficient cause Ustar bin averages have to be computed twice (or more depending on how many methods).
# TODO: wrap rest of Ustar code from fw1 around the while loop... (if necessary, depending on structure)
estUstarThresholdSingleFw2Binned <- function(
  ### estimate the Ustar threshold for single subset, using FW2 algorithm  	
  Ust_bins.f							##<< data.frame with column s NEE_avg and Ust_avg, of NEE by Ustar bins by \code{\link{binUstar}}
  ,ctrlUstarEst.l = controlUstarEst()	##<< parameter list, see \code{\link{controlUstarEst}} for defaults and description 
){  
  # algorithm to check when plateau is reached
  flag <- FALSE
  #for every u* bin compare to avg of subsequent UST_PLATEAU, until found
  u <- 1
  while (!flag){ #only stop if threshold is found
    if (!flag & (Ust_bins.f$NEE_avg[u] >= (ctrlUstarEst.l$plateauCrit*mean(Ust_bins.f$NEE_avg[(u+1):(u+ctrlUstarEst.l$ustPlateauFwd)],na.rm=T))) 
        & (Ust_bins.f$NEE_avg[u+1] >= (ctrlUstarEst.l$plateauCrit*mean(Ust_bins.f$NEE_avg[(u+1+1):(u+ctrlUstarEst.l$ustPlateauFwd+1)],na.rm=T)))){ 
      UstarThSingle <- Ust_bins.f$Ust_avg[u]        
      flag <- TRUE #set flag for threshold found in this mode

    }    
    #case that no threshold could be found by plateau method, use maximum u* in that T_class...
    if (u==(nrow(Ust_bins.f)-2)){ #FW1: -1 ; FW2: 
      UstarThSingle <- Ust_bins.f$Ust_avg[u+1]        
      break;      
    }
    u <- u+1 #increase index by 1
  }   
  return(UstarThSingle)    
}

cleanUStarSeries <- function(
	### remove non-finite cases and omit night time data.
	ds						    ##<< data.frame with columns
	,UstarColName = "Ustar"  
	,NEEColName = "NEE"
	,TempColName = "Tair"
	,RgColName = "Rg"
	,swThr = controlUstarSubsetting()$swThr
){
	ds <- subset(ds, is.finite(ds[,NEEColName]) & is.finite(ds[,TempColName]) & is.finite(ds[,UstarColName]) & is.finite(ds[,RgColName]) ) 
	#night time data selection
	ds <- ds[ ds[,RgColName] < swThr, ]
	##value<< ds with non-finite cases and cases with radiation < swThr removed.
	ds
}

estUstarThresholdYears <- function(
		### apply estUstarThresholdYear for each year in ds
		ds						    ##<< data.frame with columns
		,boot=1:nrow(ds)			##<< indices for calling by \code{link{boot}}
		,...						##<< further arguments to \code{\link{estUstarThreshold}}
		,seasonFactor.v = createSeasonFactorMonth(ds$DateTime)  ##<< factor of seasons to split
    	,yearFactor.v = as.POSIXlt(ds$DateTime)$year+1900	  	##<< factor vector (nrow(dsYear) of seasons to split 
		,UstarColName = "Ustar"  
		,NEEColName = "NEE"
		,TempColName = "Tair"
		,RgColName = "Rg"
		,ctrlUstarSub.l = controlUstarSubsetting()
		,isCleaned=FALSE			##<< set to TRUE to avoid call to \code{\link{cleanUStarSearies}}.
){
	##references<< inspired by Papale 2006
	ds$seasonFactor <- seasonFactor.v
	ds$yearFactor <- yearFactor.v
	#remove any no data records for NEE, Tair, Ustar, and Rg
	dsBoot <- ds[boot,]
	dsc <- if( isTRUE(isCleaned) ) dsBoot else cleanUStarSeries( dsBoot, UstarColName, NEEColName, TempColName, RgColName, ctrlUstarSub.l$swThr)
	
	#recover()
	
	if( !length( yearFactor.v) ){
		c( '0' = estUstarThreshold(dsc,...,ctrlUstarSub.l =ctrlUstarSub.l, isCleaned=TRUE )$UstarAggr )
	}else{
		daply( dsc, .(yearFactor), function(dsYear){ 
					if( nrow(dsYear) < 2*ctrlUstarSub.l$taClasses*ctrlUstarSub.l$UstarClasses) return( NA )
					uStar.l <- estUstarThreshold(dsYear, ... ,UstarColName = UstarColName, NEEColName = NEEColName, TempColName = TempColName, ctrlUstarSub.l =ctrlUstarSub.l, isCleaned=TRUE  )
					uStar.l$UstarAggr
				}, .inform = TRUE, .drop_o = FALSE)
#				}, .inform = FALSE)
}
	##value<< a vector with Ustar Threshold estimates. Names correspond to the year of the estimate 
}
attr(estUstarThresholdYears ,"ex") <- function(){
	Dir.s <- paste(system.file(package='REddyProc'), 'examples', sep='/')
	EddyData.F <- fLoadTXTIntoDataframe('Example_DETha98.txt', Dir.s)
	# check that is working for two years
  	dss <- subset(EddyData.F, DoY >= 150 & DoY <= 250)
	dss2 <- dss; dss2$Year <- 1999
	EddyDataWithPosix.F <- ds <- fConvertTimeToPosix(rbind(dss,dss2), 'YDH', Year.s='Year', Day.s='DoY', Hour.s='Hour')
	(res <- estUstarThresholdYears(ds))
	ds <- fConvertTimeToPosix(EddyData.F, 'YDH', Year.s='Year', Day.s='DoY', Hour.s='Hour')
	(res <- estUstarThresholdYears(ds))
	(res <- estUstarThresholdYears(subset(ds, as.POSIXlt(ds$DateTime)$year==98 )))
	(res <- estUstarThresholdYears(ds, yearFactor.v=c() ))	# works with a empty factor 
}


estUstarThresholdDistribution <- function(
		### Estimating the UstarTrhesholdDistribution by bootstrapping over data
		ds					    ##<< data.frame with columns
		,...					##<< further arguments to \code{\link{estUstarThresholdYears}}
		,seasonFactor.v = as.factor(createSeasonFactorMonth(ds$DateTime))  ##<< factor of seasons to split
		,yearFactor.v = as.factor(as.POSIXlt(ds$DateTime)$year+1900)	  	##<< factor vector (nrow(dsYear) of seasons so split dsYear 
		,nSample = 30			##<< the number of repetitions in the bootstrap
        ,probs = c(0.05,0.5,0.95)	##<< the quantiles of the bootstrap sample to return
){
		Ustar.l <- boot( ds, estUstarThresholdYears, nSample, seasonFactor.v=seasonFactor.v, yearFactor.v=yearFactor.v ) # only evaluate once
        res <- cbind( year=as.numeric(names(Ustar.l$t0)), Ustar=Ustar.l$t0, t(apply( Ustar.l$t, 2, quantile, probs=probs, na.rm=TRUE ))) 
		res
        ##value<< a matrix (nYear x (2+nProbs): first two column denoting the year and the original estimate and the other columns correponsing to the quantiles of Ustar estimate for given probabilities \code{probs}
}
attr(estUstarThresholdDistribution,"ex") <- function(){
	if( FALSE ){	# takes long, so do not do on each install or check
		# load the data and generate DateTime column
		Dir.s <- paste(system.file(package='REddyProc'), 'examples', sep='/')
		EddyData.F <- ds <- fLoadTXTIntoDataframe('Example_DETha98.txt', Dir.s)
		EddyDataWithPosix.F <- ds <- fConvertTimeToPosix(EddyData.F, 'YDH', Year.s='Year', Day.s='DoY', Hour.s='Hour')
		# initialize parallel setup and do the bootstrap 
		sfInit(parallel=TRUE,cpus=2)
		options("boot.parallel" = "snow")
		#getOption("boot.parallel")
		#options("boot.parallel" = NULL)
		(res <- estUstarThresholdDistribution(ds, nSample=20))
		#(res <- estUstarThresholdDistribution(subset(ds, as.POSIXlt(ds$DateTime)$year==98 ), nSample=20))
	}
}



